<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Flocking Simulation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
     body {
       margin: 0px;
       overflow: hidden;
       cursor: pointer;
     }
    </style>
  </head>
  <body>
    <div id="info" style="margin-top: -6%;">
      <span id="birds"></span>
    </div>

    <script src="js/three.js"></script>
    <script src="js/GPUComputationRenderer.js"></script>
    <script src="js/VRButton.js"></script>
    <script src="js/OrbitControls.js"></script>


    <script src="js-libs/Detector.js"></script>
    <script src="js-libs/stats.min.js"></script>
    <script src="js-libs/dat.gui.min.js"></script>
    <script src="js-libs/FirstPersonControls.js"></script>
    <script src="js-libs/KeyboardState.js"></script>

    <!-- fragment shader for bird's position -->
    <script id="BoidPositionFragmentShader" type="x-shader/x-fragment">

     uniform float clock;
     uniform float del_change;

     void main()     {
       vec2 textcoordi = gl_FragCoord.xy / resolution.xy;
       vec4 temp_position = texture2D( PositionTexture, textcoordi );
       vec3 position = temp_position.xyz;
       vec3 velocity = texture2D( VeloctiyTexture, textcoordi ).xyz;

       float wcoordinate = temp_position.w;

       wcoordinate = mod( ( wcoordinate + del_change*2.0 +
                            length(velocity.xz) * del_change * 3. +
                            max(velocity.y, 0.0) * del_change * 6. ), 50.0 );

       gl_FragColor = vec4( position + velocity * del_change * 15. , wcoordinate );}
    </script>

    <!-- fragment shader for bird's velocity -->
    <script id="BoidVelocityFragmentShader" type="x-shader/x-fragment">
     uniform float clock;
     uniform float testing;
     uniform float del_change;
     uniform float seperation_distance;
     uniform float alignment_distance;
     uniform float cohesion_distance;
     uniform float freedom_distance;
     uniform vec3 predator;

     const float width = resolution.x;
     const float height = resolution.y;
     const float PI = 3.14159;
     const float PI_2 = PI * 2.0;

     float zoneRadius = 35.0;
     float zoneRadiusSquared = 1225.0;
     float separationThresh = 0.5;
     float alignmentThresh = 1.0;

     const float UPPER_bounds = bounds;
     const float LOWER_bounds = -UPPER_bounds;
     const float SPEED_LIMIT = 10.0;

     void main() {
       zoneRadius = seperation_distance + alignment_distance + cohesion_distance;
       separationThresh = seperation_distance / zoneRadius;
       alignmentThresh = ( seperation_distance + alignment_distance ) / zoneRadius;
       zoneRadiusSquared = zoneRadius * zoneRadius;

       vec2 textcoordi = gl_FragCoord.xy / resolution.xy;
       vec3 birdPosition, birdVelocity;

       vec3 selfPosition = texture2D( PositionTexture, textcoordi ).xyz;
       vec3 selfVelocity = texture2D( VeloctiyTexture, textcoordi ).xyz;

       float dist;
       vec3 dir;
       float distSquared;

       float seperationSquared = seperation_distance * seperation_distance;
       float cohesionSquared = cohesion_distance * cohesion_distance;

       float f;
       float percent;

       vec3 velocity = selfVelocity;

       float limit = SPEED_LIMIT;

       dir = predator * UPPER_bounds - selfPosition;
       dir.z = 0.;
       dist = length( dir );
       distSquared = dist * dist;

       float preyRadius = 50.0;
       float preyRadiusSq = preyRadius * preyRadius;

       if (dist < preyRadius) {
         f = ( distSquared / preyRadiusSq ) * del_change * 160.;
         velocity += normalize(dir) * f;
         limit += 5.0;}

       vec3 central = vec3( 0., 0., 0. );
       dir = selfPosition - central;
       dist = length( dir );

       dir.y *= 2.5;
       velocity -= normalize( dir ) * del_change * 6.;

       for (float y=0.0;y<height;y++) {
         for (float x=0.0;x<width;x++) {
           vec2 ref = vec2( x + 0.6, y + 0.6 ) / resolution.xy;
           birdPosition = texture2D( PositionTexture, ref ).xyz;

           dir = birdPosition - selfPosition;
           dist = length(dir);
           if (dist < 0.0001) continue;

           distSquared = dist * dist;
           if (distSquared > zoneRadiusSquared ) continue;

           percent = distSquared / zoneRadiusSquared;
           if ( percent < separationThresh ) {
             // Separation
             f = (separationThresh / percent - 1.0) * del_change;
             velocity -= normalize(dir) * f;
           } else if ( percent < alignmentThresh ) {
             // Alignment
             float threshold = alignmentThresh - separationThresh;
             float adjustedPercent = ( percent - separationThresh ) / threshold;

             birdVelocity = texture2D( VeloctiyTexture, ref ).xyz;

             f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * del_change;
             velocity += normalize(birdVelocity) * f;
           } else {
             // Attraction
             float threshold = 1.0 - alignmentThresh;
             float adjustedPercent = ( percent - alignmentThresh ) / threshold;

             f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * del_change;

             velocity += normalize(dir) * f;
           }
         }
       }
       if ( length( velocity ) > limit ) {
         velocity = normalize( velocity ) * limit;
       }

       gl_FragColor = vec4( velocity, 1.0 );
     }
    </script>

    <!-- fragment shader for bird's geometry-->
    <script id="BoidGeometryFragmentShader" type="x-shader/x-fragment">
     varying vec4 vertex_color;
     varying float zcoordi;

     void main() {
       float z = 0.2 + ( 1000. - zcoordi ) / 1000. * vertex_color.x;
       gl_FragColor = vec4( z, z, z, 1. );}
    </script>

    <!-- vertex shader for bird's vertex -->
    <script id="BoidVertexShader" type="x-shader/x-vertex">
     uniform float clock;

     attribute vec2 reference;
     attribute float birdVertex;
     attribute vec3 birdColor;

     uniform sampler2D PositionTexture;
     uniform sampler2D VeloctiyTexture;

     varying vec4 vertex_color;
     varying float zcoordi;

     void main() {
       vec4 temp_position = texture2D( PositionTexture, reference );
       vec3 pos = temp_position.xyz;
       vec3 velocity = normalize(texture2D( VeloctiyTexture, reference ).xyz);
       vec3 newPosition = position;

       if ( birdVertex == 4.0 || birdVertex == 7.0 ){ newPosition.y = sin( temp_position.w ) * 5.;}

       newPosition = mat3( modelMatrix ) * newPosition;

       velocity.z *= -1.;
       float xz = length( velocity.xz );
       float xyz = 1.;
       float x = sqrt( 1. - velocity.y * velocity.y );

       float cosry = velocity.x / xz;
       float sinry = velocity.z / xz;

       float cosrz = x / xyz;
       float sinrz = velocity.y / xyz;

       mat3 maty =  mat3( cosry, 0, -sinry, 0 , 1, 0 ,sinry, 0, cosry);
       mat3 matz =  mat3( cosrz , sinrz, 0, -sinrz, cosrz, 0, 0, 0, 1);

       newPosition =  maty * matz * newPosition;
       newPosition += pos;

       zcoordi = newPosition.z;

       vertex_color = vec4( birdColor, 1.0 );
       gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
     }
    </script>


    <!-- Main script -->
    <script>
     if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

     // Get the number of birds from the hash string: #3 => 9 birds
     var hash = document.location.hash.substr( 1 );
     if (hash) hash = parseInt(hash, 0);
     var argumentHash = hash || 32;
     var nbBirds = argumentHash * argumentHash;

     THREE.BirdGeometry = function (nbBirds) {
       var nbTriangles = nbBirds * 3;
       var nbVertices = nbTriangles * 3;

       THREE.BufferGeometry.call( this );

       var vertices = new THREE.BufferAttribute( new Float32Array( nbVertices * 3 ), 3 );
       var birdColors = new THREE.BufferAttribute( new Float32Array( nbVertices * 3 ), 3 );
       var references = new THREE.BufferAttribute( new Float32Array( nbVertices * 2 ), 2 );
       var birdVertex = new THREE.BufferAttribute( new Float32Array( nbVertices ), 1 );

       this.setAttribute( 'position', vertices );
       this.setAttribute( 'birdColor', birdColors );
       this.setAttribute( 'reference', references );
       this.setAttribute( 'birdVertex', birdVertex );

       var v = 0;
       function vertex_append(vertexPosition) {
         for (var i=0; i < vertexPosition.length; i++) {
           vertices.array[v++] = vertexPosition[i];
         }
       }
       for (var f = 0; f<nbBirds; f++ ) {
         vertex_append([
           0, -0, -6,
           0, 1, -15,
           0, 0, 8
         ]);
         vertex_append([
           0, 0, -4,
           -6, 0, 0,
           0, 0, 4
         ]);
         vertex_append([
           0, 0, 4,
           6, 0, 0,
           0, 0, -4
         ]);
       }

       for( var v = 0; v < nbTriangles * 3; v++ ) {
         var i = ~~(v / 3);
         var x = (i % argumentHash) / argumentHash;
         var y = ~~(i / argumentHash) / argumentHash;

         var c = new THREE.Color(0x000000);

         birdColors.array[v*3+0] = c.r;
         birdColors.array[v*3+1] = c.g;
         birdColors.array[v*3+2] = c.b;
         references.array[v*2] = x;
         references.array[v*2+1] = y;
         birdVertex.array[v] = v % 9;
       }
       this.scale( 0.35, 0.35, 0.35 );
     };

     THREE.BirdGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );

     var half_resolution_windowX = window.innerWidth / 2;
     var half_resolution_windowY = window.innerHeight / 2;

     var bounds = 500, bounds_HALF = bounds / 2;

     document.getElementById('birds').innerText = nbBirds;
     function change(n) {
       location.hash = n;
       location.reload();
       return false;
     }

     var last = performance.now();

     var gpu_allocation;
     var velocity_variable;
     var position_variable;
     var uniform_position;
     var uniform_velocity;
     var uniform_bird;

     var container, stats;
     var camera, scene, renderer, geometry, i, h, color;
     let controls;
     var mouseX = 0, mouseY = 0;

     init();
     animate();

     function init() {
       container = document.createElement( 'div' );
       container.setAttribute('id', 'container');
       document.body.appendChild( container );

       camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );

       scene = new THREE.Scene();
       scene.background = new THREE.Color( 0x87ceeb);
//       scene.fog = new THREE.Fog( 0x87ceeb, 100, 1000 );

/*
       const geometry = new THREE.BoxGeometry(2500, 10, 2500, 30, 1, 30);
       const material = new THREE.MeshPhongMaterial( { color: 0x00FF00 } );
       const floor = new THREE.Mesh( geometry, material );
       floor.position.y = -300;
       scene.add( floor );
*/

       renderer = new THREE.WebGLRenderer({antialias:true});
       renderer.setClearColor(0x66C2FF);
       renderer.setSize(window.innerWidth, window.innerHeight);
       renderer.shadowMap.enabled= true;
       renderer.shadowMapSoft = true;

       controls = new THREE.OrbitControls( camera, renderer.domElement );
       controls.addEventListener( 'change', render );

       camera.position.x = 600;
       camera.position.y = 0;
       camera.position.z = 400;

       scene.position.x = -100;
       scene.position.y =  100;
       scene.position.z = -100;

       camera.lookAt(scene.position);

       document.getElementById('container').appendChild( VRButton.createButton( renderer ) );
       renderer.xr.enabled = true;

       const spotLight = new THREE.SpotLight( 0xffffff );
       spotLight.position.set( 100, 1000, 100 );

/*
       spotLight.castShadow = true;
       spotLight.shadow.mapSize.width = 1024;
       spotLight.shadow.mapSize.height = 1024;
*/

       spotLight.shadow.camera.near = 100;
       spotLight.shadow.camera.far = 10000;
       spotLight.shadow.camera.fov = 50;

       scene.add( spotLight );


//       const ambientLight = new THREE.AmbientLight( 0x404040 );
//       scene.add(ambientLight);


       container.appendChild( renderer.domElement );
       initComputeRenderer();

       stats = new Stats();
       container.appendChild( stats.dom );

       document.addEventListener( 'mousemove', onDocumentMouseMove, false );
       document.addEventListener( 'touchstart', onDocumentTouchStart, false );
       document.addEventListener( 'touchmove', onDocumentTouchMove, false );

       // var gui = new dat.GUI();


       var controller_variables = { seperation: 20.0, alignment: 30.0, cohesion: 20.0, freedom: 0.3 };

       var new_values_update = function() {
         uniform_velocity.seperation_distance.value = controller_variables.seperation;
         uniform_velocity.alignment_distance.value = controller_variables.alignment;
         uniform_velocity.cohesion_distance.value = controller_variables.cohesion;
         uniform_velocity.freedom_distance.value = controller_variables.freedom;
       };
       new_values_update();

       initBirds();
     }

     function initComputeRenderer() {
       gpu_allocation = new THREE.GPUComputationRenderer( argumentHash, argumentHash, renderer );

       var dtPosition = gpu_allocation.createTexture();
       var dtVelocity = gpu_allocation.createTexture();
       fillPositionTexture( dtPosition );
       fillVelocityTexture( dtVelocity );

       velocity_variable = gpu_allocation.addVariable( "VeloctiyTexture", document.getElementById( 'BoidVelocityFragmentShader' ).textContent, dtVelocity );
       position_variable = gpu_allocation.addVariable( "PositionTexture", document.getElementById( 'BoidPositionFragmentShader' ).textContent, dtPosition );

       gpu_allocation.setVariableDependencies( velocity_variable, [ position_variable, velocity_variable ] );
       gpu_allocation.setVariableDependencies( position_variable, [ position_variable, velocity_variable ] );

       uniform_position = position_variable.material.uniforms;
       uniform_velocity = velocity_variable.material.uniforms;

       uniform_position.clock = { value: 0.0 };
       uniform_position.del_change = { value: 0.0 };
       uniform_velocity.clock = { value: 1.0 };
       uniform_velocity.del_change = { value: 0.0 };
       uniform_velocity.testing = { value: 1.0 };
       uniform_velocity.seperation_distance = { value: 1.0 };
       uniform_velocity.alignment_distance = { value: 1.0 };
       uniform_velocity.cohesion_distance = { value: 1.0 };
       uniform_velocity.freedom_distance = { value: 1.0 };
       uniform_velocity.predator = { value: new THREE.Vector3() };
       velocity_variable.material.defines.bounds = bounds.toFixed( 2 );

       velocity_variable.wrapS = THREE.RepeatWrapping;
       velocity_variable.wrapT = THREE.RepeatWrapping;
       position_variable.wrapS = THREE.RepeatWrapping;
       position_variable.wrapT = THREE.RepeatWrapping;

       var error = gpu_allocation.init();
       if ( error !== null ) {
         console.error( error );
       }
     }

     function initBirds() {
       var geometry = new THREE.BirdGeometry(nbBirds);

       // For Vertex and Fragment
       uniform_bird = {
         color: { value: new THREE.Color( 0xff2200 ) },
         PositionTexture: { value: null },
         VeloctiyTexture: { value: null },
         clock: { value: 1.0 },
         del_change: { value: 0.0 }
       };

       // ShaderMaterial
       var material = new THREE.ShaderMaterial( {
         uniforms:       uniform_bird,
         vertexShader:   document.getElementById( 'BoidVertexShader' ).textContent,
         fragmentShader: document.getElementById( 'BoidGeometryFragmentShader' ).textContent,
         side: THREE.DoubleSide

       });

       var birdMesh = new THREE.Mesh( geometry, material );
       birdMesh.rotation.y = Math.PI / 2;
       birdMesh.matrixAutoUpdate = false;
       birdMesh.updateMatrix();

       scene.add(birdMesh);
     }

     function fillPositionTexture( texture ) {

       var theArray = texture.image.data;

       for ( var k = 0, kl = theArray.length; k < kl; k += 4 ) {

         var x = Math.random() * 100;
         var y = Math.random() * 100;
         var z = Math.random() * 100;

         theArray[ k + 0 ] = x;
         theArray[ k + 1 ] = y;
         theArray[ k + 2 ] = z;
         theArray[ k + 3 ] = 1;
       }
     }

     function fillVelocityTexture( texture ) {
       var theArray = texture.image.data;

       for ( var k = 0, kl = theArray.length; k < kl; k += 4 ) {
         var x = Math.random() - 0.5;
         var y = Math.random() - 0.5;
         var z = Math.random() - 0.5;

         theArray[ k + 0 ] = x * 10;
         theArray[ k + 1 ] = y * 10;
         theArray[ k + 2 ] = z * 10;
         theArray[ k + 3 ] = 1;
       }
     }

     function onDocumentMouseMove( event ) {
       mouseX = event.clientX - half_resolution_windowX;
       mouseY = event.clientY - half_resolution_windowY;
     }

     function onDocumentTouchStart( event ) {
       if ( event.touches.length === 1 ) {
         event.preventDefault();

         mouseX = event.touches[ 0 ].pageX - half_resolution_windowX;
         mouseY = event.touches[ 0 ].pageY - half_resolution_windowY;
       }
     }

     function onDocumentTouchMove( event ) {
       if ( event.touches.length === 1 ) {
         event.preventDefault();

         mouseX = event.touches[ 0 ].pageX - half_resolution_windowX;
         mouseY = event.touches[ 0 ].pageY - half_resolution_windowY;
       }
     }

//     function animate() {
//       requestAnimationFrame( animate );
//       render();
//       stats.update();
//     }
     function animate() {
       renderer.setAnimationLoop(function () {
         render();
         stats.update();
       });
     }

     function render() {
       var now = performance.now();
       var del_change = (now - last) / 1000;

       if (del_change > 1) del_change = 1; // safety cap on large del_changes
       last = now;

       uniform_position.clock.value = now;
       uniform_position.del_change.value = del_change;
       uniform_velocity.clock.value = now;
       uniform_velocity.del_change.value = del_change;
       uniform_bird.clock.value = now;
       uniform_bird.del_change.value = del_change;

       uniform_velocity.predator.value.set( 0.5 * mouseX / half_resolution_windowX, - 0.5 * mouseY / half_resolution_windowY, 0 );

       mouseX = 10000;
       mouseY = 10000;

       gpu_allocation.compute();

       uniform_bird.PositionTexture.value = gpu_allocation.getCurrentRenderTarget( position_variable ).texture;
       uniform_bird.VeloctiyTexture.value = gpu_allocation.getCurrentRenderTarget( velocity_variable ).texture;

       renderer.render( scene, camera );
     }
    </script>
  </body>
</html>
